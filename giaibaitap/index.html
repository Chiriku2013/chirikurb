<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Trang Gi·∫£i B√†i T·∫≠p -- Chiriku Roblox</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { font-family: Arial, sans-serif; background: #111; color: #eee; margin:0; padding:15px; text-align:center; }
h1 { color: #4caf50; font-size: 1.5em; }
textarea, input, button { width: 100%; margin: 8px 0; padding: 12px; border-radius: 8px; border: none; font-size: 1em; }
textarea { min-height: 100px; resize: vertical; }
button { background: #4caf50; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.1em; }
button:hover { background: #45a049; }
#result { margin-top: 20px; padding: 15px; background: #222; border-radius: 8px; text-align: left; font-size: 1em; line-height: 1.6; overflow-x: auto; word-wrap: break-word; }
pre { background: #333; padding: 10px; border-radius: 6px; overflow-x: auto; }
code { background: #333; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
b { color: #ffd700; } i { color: #ffa07a; } del { color: #ff6961; }
ul { padding-left: 20px; } a { color: #4da6ff; text-decoration: underline; }
img.generated { max-width: 100%; border-radius: 8px; margin-top: 10px; }
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<h1>Trang Gi·∫£i B√†i T·∫≠p -- Chiriku Roblox</h1>

<textarea id="textInput" placeholder="Nh·∫≠p ƒë·ªÅ b√†i ho·∫∑c y√™u c·∫ßu th√™m..."></textarea><br>
<input type="file" id="imageInput" accept="image/*" multiple><br>
<button id="solveBtn">B·∫Øt ƒë·∫ßu gi·∫£i b√†i</button>
<button id="imgGenBtn">T·∫°o h√¨nh ·∫£nh t·ª´ prompt</button>
<div id="result">K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
const API_KEY = "AIzaSyCQ26QOV8JtdVzy3Bgq7VgPh82UO54k57o"; // Thay b·∫±ng Gemini API key
const MODEL = "gemini-2.5-flash";
const IMAGE_MODEL = "imagen-3.0"; // Model t·∫°o h√¨nh ·∫£nh

function detectLanguage(text){
    const vietnameseChars = /[ƒÉ√¢ƒë√™√¥∆°∆∞√°√†·∫£√£·∫°·∫Ø·∫±·∫≥·∫µ·∫∑·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç·ªë·ªì·ªï·ªó·ªô·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ]/i;
    return vietnameseChars.test(text) ? "Ti·∫øng Vi·ªát" : "English";
}

function buildSystemPrompt(lang){
    return `
B·∫°n l√† tr·ª£ l√Ω AI si√™u th√¥ng minh, lu√¥n tr·∫£ l·ªùi **ng·∫Øn g·ªçn, ch·ªâ k·∫øt qu·∫£ cu·ªëi n·∫øu c√≥ ph√©p t√≠nh**, kh√¥ng gi·∫£i chi ti·∫øt. 
- To√°n/L√Ω/H√≥a: tr·∫£ l·ªùi **c√¥ng th·ª©c ‚Üí thay s·ªë ‚Üí t√≠nh ‚Üí k·∫øt qu·∫£ cu·ªëi + ƒë∆°n v·ªã**.
- VƒÉn/S·ª≠/ƒê·ªãa/Anh: tr·∫£ l·ªùi ƒë·∫ßy ƒë·ªß √Ω, m·∫°ch l·∫°c, ng·∫Øn g·ªçn.
- Ng√¥n ng·ªØ tr·∫£ l·ªùi: ${lang}.
`;
}

function formatText(text){
    return text
        .replace(/```([\s\S]*?)```/g,"<pre><code>$1</code></pre>")
        .replace(/`([^`]+)`/g,"<code>$1</code>")
        .replace(/\*\*(.*?)\*\*/g,"<b>$1</b>")
        .replace(/(\*|_)(.*?)\1/g,"<i>$2</i>")
        .replace(/~~(.*?)~~/g,"<del>$1</del>")
        .replace(/^- (.*)$/gm,"<ul><li>$1</li></ul>")
        .replace(/^\* (.*)$/gm,"<ul><li>$1</li></ul>")
        .replace(/(https?:\/\/[^\s]+)/g,'<a href="$1" target="_blank">$1</a>')
        .replace(/\n/g,"<br>");
}

async function callGemini(userParts, lang){
    const body = { contents: [
        { role:"user", parts:[{text: buildSystemPrompt(lang)}] },
        { role:"user", parts:userParts }
    ]};
    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${API_KEY}`, {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify(body)
    });
    return await res.json();
}

async function generateImage(prompt){
    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${IMAGE_MODEL}:generateImage?key=${API_KEY}`, {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ prompt: { text: prompt }, size: "1024x1024" })
    });
    return await res.json();
}

async function displayResult(text){
    const resultDiv = document.getElementById("result");
    resultDiv.innerHTML = formatText(text);
    if(window.MathJax){
        MathJax.typesetPromise([resultDiv])
            .catch(err=>console.error("‚ùå MathJax error:", err));
    }
}

// Solve text + OCR nhi·ªÅu ·∫£nh
document.getElementById("solveBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("textInput").value.trim();
    const files = document.getElementById("imageInput").files;
    const resultDiv = document.getElementById("result");

    if(!text && files.length===0){ resultDiv.textContent="‚ùå H√£y nh·∫≠p ƒë·ªÅ b√†i ho·∫∑c ch·ªçn ·∫£nh."; return; }

    try{
        let finalText = text;
        if(files.length > 0){
            resultDiv.textContent="üîç ƒêang OCR nhi·ªÅu ·∫£nh...";
            for(const file of files){
                const dataUrl = await new Promise(r=>{
                    const reader = new FileReader();
                    reader.onload=()=>r(reader.result);
                    reader.readAsDataURL(file);
                });
                const { data:{ text: ocrText } } = await Tesseract.recognize(dataUrl, 'eng+vie');
                finalText += "\n" + ocrText.trim();
            }
        }
        const lang = detectLanguage(finalText);
        resultDiv.textContent="‚è≥ ƒêang g·ªçi AI... ("+lang+")";
        const data = await callGemini([{text: finalText}], lang);

        if(data?.candidates?.length > 0){
            const firstCandidate = data.candidates[0];
            let outputText = "";

            if(firstCandidate.content?.parts?.length){
                outputText = firstCandidate.content.parts
                    .map(p => p.text || "")
                    .join("\n")
                    .trim();
            }

            if(outputText){
                await displayResult(outputText);
            } else {
                resultDiv.textContent = "‚ùå API tr·∫£ v·ªÅ r·ªóng (kh√¥ng c√≥ text).";
                console.log("Response:", data);
            }
        } else {
            resultDiv.textContent = "‚ùå API kh√¥ng tr·∫£ k·∫øt qu·∫£.";
            console.log("Response:", data);
        }
    } catch(err){
        resultDiv.textContent="‚ùå L·ªói: "+err.message;
    }
});

// Sinh h√¨nh ·∫£nh
document.getElementById("imgGenBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("textInput").value.trim();
    const resultDiv = document.getElementById("result");

    if(!text){ resultDiv.textContent="‚ùå H√£y nh·∫≠p prompt ƒë·ªÉ t·∫°o h√¨nh."; return; }

    try{
        resultDiv.textContent="üé® ƒêang t·∫°o h√¨nh ·∫£nh...";
        const data = await generateImage(text);
        if(data.images?.length){
            resultDiv.innerHTML = `<p>‚úÖ ·∫¢nh ƒë√£ t·∫°o:</p>`;
            data.images.forEach(img=>{
                resultDiv.innerHTML += `<img class="generated" src="data:image/png;base64,${img.base64}" alt="Generated Image">`;
            });
        } else {
            resultDiv.textContent="‚ùå API kh√¥ng tr·∫£ ·∫£nh.";
            console.log("Image Response:", data);
        }
    } catch(err){
        resultDiv.textContent="‚ùå L·ªói t·∫°o ·∫£nh: "+err.message;
    }
});
</script>
</body>
</html>
