<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Trang Gi·∫£i B√†i T·∫≠p -- Chiriku Roblox</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { font-family: Arial, sans-serif; background: #111; color: #eee; margin:0; padding:15px; text-align:center; }
h1 { color: #4caf50; font-size: 1.5em; }
textarea, input, button { width: 100%; margin: 8px 0; padding: 12px; border-radius: 8px; border: none; font-size: 1em; }
textarea { min-height: 100px; resize: vertical; }
button { background: #4caf50; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.1em; }
button:hover { background: #45a049; }
#result { margin-top: 20px; padding: 15px; background: #222; border-radius: 8px; text-align: left; font-size: 1em; line-height: 1.6; overflow-x: auto; word-wrap: break-word; }
pre { background: #333; padding: 10px; border-radius: 6px; overflow-x: auto; }
code { background: #333; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
b { color: #ffd700; } i { color: #ffa07a; } del { color: #ff6961; }
ul { padding-left: 20px; } a { color: #4da6ff; text-decoration: underline; }
img.generated { max-width: 100%; border-radius: 8px; margin-top: 10px; }
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<h1>Trang Gi·∫£i B√†i T·∫≠p -- Chiriku Roblox</h1>

<textarea id="textInput" placeholder="Nh·∫≠p ƒë·ªÅ b√†i ho·∫∑c y√™u c·∫ßu th√™m..."></textarea><br>
<input type="file" id="imageInput" accept="image/*" multiple><br>
<button id="solveBtn">B·∫Øt ƒë·∫ßu gi·∫£i b√†i</button>
<button id="imgGenBtn">T·∫°o h√¨nh ·∫£nh t·ª´ prompt</button>
<div id="result">K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
const API_KEY = "AIzaSyCQ26QOV8JtdVzy3Bgq7VgPh82UO54k57o"; // Gemini API key
const MODEL = "gemini-2.5-flash";
const IMAGE_MODEL = "imagen-3.0";

// Detect language
function detectLanguage(text){
    const vn = /[ƒÉ√¢ƒë√™√¥∆°∆∞√°√†·∫£√£·∫°·∫Ø·∫±·∫≥·∫µ·∫∑·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç·ªë·ªì·ªï·ªó·ªô·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ]/i;
    return vn.test(text) ? "Ti·∫øng Vi·ªát" : "English";
}

// System prompt
function buildSystemPrompt(lang){
    return `
B·∫°n l√† tr·ª£ l√Ω AI si√™u th√¥ng minh, lu√¥n tr·∫£ l·ªùi **ng·∫Øn g·ªçn, ch·ªâ k·∫øt qu·∫£ cu·ªëi n·∫øu c√≥ ph√©p t√≠nh**, kh√¥ng gi·∫£i chi ti·∫øt. 
- To√°n/L√Ω/H√≥a: tr·∫£ l·ªùi **c√¥ng th·ª©c ‚Üí thay s·ªë ‚Üí t√≠nh ‚Üí k·∫øt qu·∫£ cu·ªëi + ƒë∆°n v·ªã**.
- VƒÉn/S·ª≠/ƒê·ªãa/Anh: tr·∫£ l·ªùi ƒë·∫ßy ƒë·ªß √Ω, m·∫°ch l·∫°c, ng·∫Øn g·ªçn.
- Ng√¥n ng·ªØ tr·∫£ l·ªùi: ${lang}.
`;
}

// Format text v·ªõi markdown nh·∫π
function formatText(text){
    return text
        .replace(/```([\s\S]*?)```/g,"<pre><code>$1</code></pre>")
        .replace(/`([^`]+)`/g,"<code>$1</code>")
        .replace(/\*\*(.*?)\*\*/g,"<b>$1</b>")
        .replace(/(\*|_)(.*?)\1/g,"<i>$2</i>")
        .replace(/~~(.*?)~~/g,"<del>$1</del>")
        .replace(/^- (.*)$/gm,"<ul><li>$1</li></ul>")
        .replace(/^\* (.*)$/gm,"<ul><li>$1</li></ul>")
        .replace(/(https?:\/\/[^\s]+)/g,'<a href="$1" target="_blank">$1</a>')
        .replace(/\n/g,"<br>");
}

// Call Gemini API
async function callGemini(userParts, lang){
    const body = { contents: [
        { role:"user", parts:[{text: buildSystemPrompt(lang)}] },
        { role:"user", parts:userParts }
    ]};
    const res = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${API_KEY}`,
        { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body) }
    );
    return await res.json();
}

// Image gen API
async function generateImage(prompt){
    const res = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/${IMAGE_MODEL}:generateImage?key=${API_KEY}`,
        { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({ prompt: { text: prompt }, size: "1024x1024" }) }
    );
    return await res.json();
}

// Display
async function displayResult(text){
    const resultDiv = document.getElementById("result");
    resultDiv.innerHTML = formatText(text);
    if(window.MathJax){
        MathJax.typesetPromise([resultDiv]).catch(err=>console.error("‚ùå MathJax:", err));
    }
}

// OCR song song nhi·ªÅu ·∫£nh
async function ocrMultipleImages(files){
    const tasks = [...files].map(file => new Promise(resolve=>{
        const reader = new FileReader();
        reader.onload=()=>{
            Tesseract.recognize(reader.result, 'eng+vie').then(({data:{text}})=>{
                resolve(text.trim());
            }).catch(e=>{
                console.error("OCR error:", e);
                resolve("");
            });
        };
        reader.readAsDataURL(file);
    }));
    return await Promise.all(tasks);
}

// Solve button
document.getElementById("solveBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("textInput").value.trim();
    const files = document.getElementById("imageInput").files;
    const resultDiv = document.getElementById("result");

    if(!text && files.length===0){ resultDiv.textContent="‚ùå H√£y nh·∫≠p ƒë·ªÅ b√†i ho·∫∑c ch·ªçn ·∫£nh."; return; }

    try{
        let finalText = text;
        if(files.length > 0){
            resultDiv.textContent="üîç ƒêang OCR nhi·ªÅu ·∫£nh...";
            const texts = await ocrMultipleImages(files);
            finalText += "\n" + texts.filter(t=>t).join("\n");
        }

        const lang = detectLanguage(finalText);
        resultDiv.textContent="‚è≥ ƒêang g·ªçi AI... ("+lang+")";

        const data = await callGemini([{text: finalText}], lang);

        if(data?.candidates?.length){
            const first = data.candidates[0];
            let output = first.content?.parts?.map(p=>p.text||"").join("\n").trim();
            if(output) await displayResult(output);
            else resultDiv.textContent="‚ùå API tr·∫£ v·ªÅ r·ªóng.";
        } else {
            resultDiv.textContent="‚ùå API kh√¥ng tr·∫£ k·∫øt qu·∫£.";
        }
    } catch(err){
        resultDiv.textContent="‚ùå L·ªói: "+err.message;
    }
});

// Image button
document.getElementById("imgGenBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("textInput").value.trim();
    const resultDiv = document.getElementById("result");

    if(!text){ resultDiv.textContent="‚ùå H√£y nh·∫≠p prompt ƒë·ªÉ t·∫°o h√¨nh."; return; }

    try{
        resultDiv.textContent="üé® ƒêang t·∫°o h√¨nh ·∫£nh...";
        const data = await generateImage(text);

        // Check c·∫£ 2 tr∆∞·ªùng h·ª£p: data.images ho·∫∑c data.image
        const imgs = data.images || data.image || [];
        if(imgs.length){
            resultDiv.innerHTML = `<p>‚úÖ ·∫¢nh ƒë√£ t·∫°o:</p>` + 
                imgs.map(img=>`<img class="generated" src="data:image/png;base64,${img.base64}" alt="Generated">`).join("");
        } else {
            resultDiv.textContent="‚ùå API kh√¥ng tr·∫£ ·∫£nh.";
            console.log("Image resp:", data);
        }
    } catch(err){
        resultDiv.textContent="‚ùå L·ªói t·∫°o ·∫£nh: "+err.message;
    }
});
</script>
</body>
</html>
