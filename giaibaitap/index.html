<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Sigma Bot Web</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { font-family: Arial, sans-serif; background: #111; color: #eee; margin:0; padding:15px; text-align:center; }
h1 { color: #4caf50; font-size: 1.5em; }
textarea, input, button { width: 100%; margin: 8px 0; padding: 12px; border-radius: 8px; border: none; font-size: 1em; }
textarea { min-height: 100px; resize: vertical; }
button { background: #4caf50; color: #fff; font-weight: bold; cursor: pointer; font-size: 1.1em; }
button:hover { background: #45a049; }
#result { margin-top: 20px; padding: 15px; background: #222; border-radius: 8px; text-align: left; font-size: 1em; line-height: 1.6; overflow-x: auto; word-wrap: break-word; }
pre { background: #333; padding: 10px; border-radius: 6px; overflow-x: auto; }
code { background: #333; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
b { color: #ffd700; } i { color: #ffa07a; } del { color: #ff6961; }
ul { padding-left: 20px; } a { color: #4da6ff; text-decoration: underline; }
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<h1>Sigma Bot Web</h1>

<textarea id="textInput" placeholder="Nh·∫≠p ƒë·ªÅ b√†i ho·∫∑c y√™u c·∫ßu th√™m..."></textarea><br>
<input type="file" id="imageInput" accept="image/*"><br>
<button id="solveBtn">B·∫Øt ƒë·∫ßu gi·∫£i b√†i</button>
<div id="result">K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
const API_KEY = "AIzaSyCQ26QOV8JtdVzy3Bgq7VgPh82UO54k57o"; // Thay b·∫±ng Gemini API key
const MODEL = "gemini-2.5-flash";

// Detect language
function detectLanguage(text){
    const vietnameseChars = /[ƒÉ√¢ƒë√™√¥∆°∆∞√°√†·∫£√£·∫°·∫Ø·∫±·∫≥·∫µ·∫∑·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç·ªë·ªì·ªï·ªó·ªô·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ]/i;
    if(vietnameseChars.test(text)) return "Ti·∫øng Vi·ªát";
    return "English";
}

// System prompt t·ªëi ∆∞u: ng·∫Øn g·ªçn
function buildSystemPrompt(lang){
    return `
B·∫°n l√† tr·ª£ l√Ω AI si√™u th√¥ng minh, lu√¥n tr·∫£ l·ªùi **ng·∫Øn g·ªçn, ch·ªâ k·∫øt qu·∫£ cu·ªëi n·∫øu c√≥ ph√©p t√≠nh**, kh√¥ng gi·∫£i chi ti·∫øt. 
- To√°n/L√Ω/H√≥a: tr·∫£ l·ªùi **c√¥ng th·ª©c ‚Üí thay s·ªë ‚Üí t√≠nh ‚Üí k·∫øt qu·∫£ cu·ªëi + ƒë∆°n v·ªã**, ng·∫Øn g·ªçn, kh√¥ng gi·∫£i th√≠ch d√†i. 
- VƒÉn/S·ª≠/ƒê·ªãa/Anh: tr·∫£ l·ªùi ƒë·∫ßy ƒë·ªß √Ω, m·∫°ch l·∫°c, ng·∫Øn g·ªçn.
- Ng√¥n ng·ªØ tr·∫£ l·ªùi: ${lang}.
`;
}

// Format text cho HTML + MathJax
function formatText(text){
    return text
        .replace(/```([\s\S]*?)```/g,"<pre><code>$1</code></pre>")
        .replace(/`([^`]+)`/g,"<code>$1</code>")
        .replace(/\*\*(.*?)\*\*/g,"<b>$1</b>")
        .replace(/(\*|_)(.*?)\1/g,"<i>$2</i>")
        .replace(/~~(.*?)~~/g,"<del>$1</del>")
        .replace(/^- (.*)$/gm,"<ul><li>$1</li></ul>")
        .replace(/^\* (.*)$/gm,"<ul><li>$1</li></ul>")
        .replace(/(https?:\/\/[^\s]+)/g,'<a href="$1" target="_blank">$1</a>')
        .replace(/\n/g,"<br>");
}

// G·ªçi API Gemini
async function callGemini(userParts, lang){
    const body = { contents: [
        { role:"user", parts:[{text: buildSystemPrompt(lang)}] },
        { role:"user", parts:userParts }
    ]};
    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${API_KEY}`, {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify(body)
    });
    return await res.json();
}

// Hi·ªÉn th·ªã k·∫øt qu·∫£
async function displayResult(text){
    const resultDiv = document.getElementById("result");
    resultDiv.innerHTML = formatText(text);
    if(window.MathJax){
        MathJax.typesetPromise([resultDiv])
            .then(()=>console.log("‚úÖ MathJax rendered"))
            .catch(err=>console.error("‚ùå MathJax error:", err));
    }
}

// Event n√∫t Solve
document.getElementById("solveBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("textInput").value.trim();
    const file = document.getElementById("imageInput").files[0];
    const resultDiv = document.getElementById("result");

    if(!text && !file){ resultDiv.textContent="‚ùå H√£y nh·∫≠p ƒë·ªÅ b√†i ho·∫∑c ch·ªçn ·∫£nh."; return; }

    try{
        let finalText = text;
        if(file){
            resultDiv.textContent="üîç ƒêang nh·∫≠n d·∫°ng vƒÉn b·∫£n...";
            const reader = new FileReader();
            reader.onload = async ()=>{
                const { data:{ text: ocrText } } = await Tesseract.recognize(reader.result, 'eng+vie', {
                    logger: info => { if(info.status==="recognizing text") resultDiv.textContent=`üîç OCR: ${Math.round(info.progress*100)}%`; }
                });
                finalText = (text? text+"\n":"") + ocrText.trim();
                const lang = detectLanguage(finalText);
                resultDiv.textContent="‚è≥ ƒêang g·ªçi AI... ("+lang+")";
                const data = await callGemini([{text: finalText}], lang);
                if(data.candidates?.length) await displayResult(data.candidates[0].content.parts[0].text);
                else resultDiv.textContent="‚ùå API kh√¥ng tr·∫£ k·∫øt qu·∫£.";
            };
            reader.readAsDataURL(file);
        } else {
            const lang = detectLanguage(finalText);
            resultDiv.textContent="‚è≥ ƒêang g·ªçi AI... ("+lang+")";
            const data = await callGemini([{text: finalText}], lang);
            if(data.candidates?.length) await displayResult(data.candidates[0].content.parts[0].text);
            else resultDiv.textContent="‚ùå API kh√¥ng tr·∫£ k·∫øt qu·∫£.";
        }
    } catch(err){
        resultDiv.textContent="‚ùå L·ªói: "+err.message;
    }
});
</script>
</body>
</html>
